# task_gridnine_system
## Выполнение тестового задания на позицию Java Developer.
***
### Файловая организация проекта.
task_gridnine_system/src/\
├── "_"main/\
│   ├── java/\
│   │   └── com/\
│   │       └── gridnine/\
│   │           └── testing/\
│   │               ├── Solution.java\
│   │               │   ├── [DepartureBeforeNowFilter](https://github.com/SQroller/task_gridnine_system/blob/main/java_jun_testing/src/main/java/com/gridnine/testing/Solution.java#L12) - **Фильтр, исключающий перелёты с вылетом до текущего момента времени.**\
│   │               │   ├── [ArrivalBeforeDepartureFilter](https://github.com/SQroller/task_gridnine_system/blob/main/java_jun_testing/src/main/java/com/gridnine/testing/Solution.java#L23) - **Фильтр, исключающий перелёты, где имеются сегменты с датой прилёта раньше даты вылета.**\
│   │               │   ├── [ExcessiveGroundTimeFilter](https://github.com/SQroller/task_gridnine_system/blob/main/java_jun_testing/src/main/java/com/gridnine/testing/Solution.java#L33) - **Фильтр, исключающий перелёты, где общее время на земле превышает два часа.**\
│   │               │   └── [FlightFilter](https://github.com/SQroller/task_gridnine_system/blob/main/java_jun_testing/src/main/java/com/gridnine/testing/Solution.java#L8) - **Интерфейс для правил фильтрации.**\
│   │               ├── TestClasses.java\
│   │               │   ├── FlightBuilder\
│   │               │   ├── Flight\
│   │               │   └── Segment\
│   │               └── Main.java\
│   └── resources/\
│       ├── questionary.odt - **Вопросы о Java с ответами.**\
│       └── test-instructions.odt - **Постановка задачи.**\
└── test/java/com/gridnine/testing/FlightFilterTest.java - тестирование.
***
### Используемые зависимости.
Для тестирования:\
JUnit 5\
junit-jupiter-engine 5.7.0
***
### Вопросы и ответы.
### Вопросы и ответы.
* **Вопрос 1. Что такое переопределение метода?**\
Это механизм объектно-ориентированного программирования, который позволяет подклассу (дочернему классу) предоставить специфическую реализацию метода, который уже определен в его суперклассе (родительском классе). Когда метод в подклассе переопределяет метод суперкласса, то при вызове этого метода на объекте подкласса будет использована реализация метода из подкласса.
Для переопределения метода используется аннотация @Override
* **Вопрос 2. Какие бывают виды классов?**\
*Обычные классы* - стандартные классы, которые используются для создания объектов. Они могут содержать поля, методы, конструкторы и блоки инициализации;
*Интерфейсы* - классы, которые могут содержать только абстрактные и статические методы в зависимости от версии Java;
*Абстрактные* - классы, которые не могут быть инстанциированы и могут содержать абстрактные методы (без реализации), а также обычные методы с реализацией;
*Вложенные и внутренние* - объявляются внутри другого класса. Они могут быть статическими (nested static classes) или нестатическими (inner classes);
*Локальные* - объявляются внутри метода и имеют доступ к переменным этого метода;
*Анонимные* - используются для создания экземпляров классов с одновременной реализацией или расширением другого класса или интерфейса;
*Перечисления* -  используются для определения набора фиксированных констант;
*Записи* - особый вид классов для хранения неизменяемых данных. Они автоматически предоставляют конструктор, equals(), hashCode(), и toString() методы.
* **Вопрос 3. Как и зачем можно использовать модификатор final?**\
Данное ключевое слово используется для обозначения того, что значение переменной не может быть изменено после его инициализации.
* **Вопрос 4. Какие есть варианты использования ключевого слова try?**\
Есть несколько вариантов использования *try*:
*try-catch, try-catch-finally, try-finally.*
 - *try* – определяет блок кода, в котором может произойти исключение;
 - *catch* – определяет блок кода, в котором происходит обработка исключения;
 - *finally* – определяет блок кода, который является необязательным, но при его наличии выполняется в любом случае независимо от результатов выполнения блока try.
* **Вопрос 5. Какие есть стандартные реализации интерфейса List и в каких ситуациях их нужно использовать?**\
*ArrayList, LinkedList, Vector(deprecated).*
Ситуиации для использования:
1. *ArrayList* - базируется на массиве, который автоматически расширяется по мере добавления новых элементов. Это наиболее часто используемая реализация.
*Использование:*
  * Когда нужно быстрое чтение по индекусу.
  * Когда операции вставки и удаления в середине списка редки.
2. *LinkedList* - базируется на двусвязном списке, где каждый элемент содержит ссылки на предыдущий и следующий элементы.
*Использование:*
 * Когда нужно часто вставлять и удалять элементы в середину списка.
 * Когда требуется реализация очереди или двусторонней очереди (Deque).
3. *Vector* - является односвязным списком, синхронизированным, что делает его безопасным для многопоточной среды.
*Использование:*
 * Если нужна синхронизированная коллекция.
* **Вопрос 6. В чём основная идея стримов из пакета java.util.stream?**\
Упростить работу с наборами данных, в частности, упростить операции фильтрации, сортировки и другие манипуляции с данными.
* **Доп. вопрос 1. Каким критериям должна удовлетворять «хорошая» хэш-функция?**\
1. *Однозначность (Determinism):* Одна и та же входная строка всегда должна приводить к одному и тому же хэш-значению.
2. *Равномерное распределение:* Хорошая хэш-функция должна равномерно распределять хэш-значения по всему пространству хэш-значений.
3. *Минимизация коллизий:* Хотя полностью избежать коллизий невозможно, хэш-функция должна минимизировать их количество. Коллизии приводят к дополнительной работе при обработке данных, что снижает производительность.
4. *Скорость:* Хэш-функция должна быть быстрой в вычислении, чтобы не замедлять процесс хэширования больших объемов данных.
5. *Низкая чувствительность к незначительным изменениям (Avalanche effect):* Небольшое изменение входных данных должно приводить к значительному изменению в хэш-значении.
6. *Стойкость к атакам (Cryptographic properties, для криптографических хэш-функций):* Для криптографических хэш-функций важно, чтобы они были устойчивы к различным видам атак.
7. *Простота реализации:* Хэш-функция должна быть простой в реализации и не требовать чрезмерных вычислительных ресурсов.
* **Доп. вопрос 2. В чём причина популярности и широкого распространения кодировки UTF-8?**\
 - UTF-8 совместим с ASCII и кодирует его символы в один байт, обеспечивая отменую обратную совместимость.
 - UTF-8 использует от 1 до 4 байтов на символ, эффективно справляясь с широким спектром символов разной сложности.
 - UTF-8 не требует маркера порядка байтов (BOM), что делает его универсальным в вопросах порядка байт, упрощая обмен данными между системами.
 - UTF-8 помогает предотвратить возможные уязвимости безопасности.
* **Доп. вопрос 3. Сравните форматы XML и JSON. Когда какой использовать?**\
 - XML использует теги для организации данных в иерархической структуре, что делает его подходящим для сложных схем данных и сильной типизации. Он часто используется в системах, где важна валидация данных и поддержка различных языков. 
 - С другой стороны, JSON представляет данные в виде пар "ключ-значение" и массивов, что делает его более компактным и легкочитаемым для машины. JSON чаще всего применяется в веб-разработке и API, где требуется простота и эффективность передачи данных. 
* **Доп. вопрос 4. Опишите что будет происходить «под капотом» после ввода адреса сайта в браузере и нажатия Enter?**\
 - Сначала браузер отправляет запрос на сервер, содержащий URL запрашиваемой страницы. Затем операционная система браузера консультируется с DNS сервером для разрешения доменного имени в IP-адрес сервера. Как только браузер получает IP-адрес, он устанавливает TCP-соединение с сервером.
 - После установки соединения браузер отправляет HTTP запрос на сервер. Этот запрос содержит метод запроса (GET, POST, DELETE и тд), URL страницы, заголовки запроса и, возможно, тело запроса. Сервер получает запрос и обрабатывает его. Он ищет запрашиваемый ресурс на сервере, выполняет необходимые операции (например, обращается к базе данных для получения данных) и генерирует HTTP ответ.
 - HTTP ответ включает в себя статус ответа (например, 200 OK, 404 Not Found), заголовки ответа и содержимое страницы. Если статус ответа успешный и содержит HTML контент, браузер начинает загружать этот контент. Он обрабатывает HTML код страницы, загружает связанные ресурсы, такие как CSS, JavaScript и изображения, и начинает отображать содержимое страницы на экране пользователя.
 - Этот процесс включает в себя множество шагов, включая установку соединения, обмен данными между браузером и сервером, обработку запросов и ответов, а также рендеринг содержимого страницы для отображения пользователю.
